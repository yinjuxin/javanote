psvm,回车直接创建main方法
sout,回车直接创建打印语句

alt+4,显示/隐藏下方的结果框

out文件夹是存储对应包下的class文件

keymap补全代码快捷键设置
	-settings-keymap-先duplicate一份用于备份-main menu-code-code completion-basic
	-remove原有的快捷键-设置为ctrl+/(斜杠上面的问号）

alt+回车 修改代码，导包
ctrl+y 删除光标当前行
ctrl+d 重复
ctrl+alt+l 格式化代码
ctrl+l 单行注释
ctrl+shift+l 多行注释（选全）
alt+insert 自动生成代码，toString，get，set方法
alt+shift+上下箭头 移动行

shift + enter 在任意位置光标向下跳
ctrl + alt + enter 光标向上，当前向下一行

从刚开始就打开idea，之后new一个新的project，之后new一个module ，接着在src中new一个package
导入移除的module -settings下面的project structure -点击加号 -import module

快速创建循环 -循环次数.fori(5.fori)
数组的快速遍历 array.fori 逆序遍历 array.forr

【方法】
	注意事项：
		1. 方法定义的先后顺序无所谓
		2. 方法定义必须是挨着的，不能在一个方法的内部定义另一个方法
		3. 方法定义之后，自己不会执行，需要调用

【重载】：方法名相同，参数列表不同
	- 方法重载与下列因素相关：
		1. 参数的个数不同
		2. 参数的类型不同
		3. 参数的多类型顺序不同

	- 方法重载与下列因素无关：
		1. 与参数名称无关
		2. 与返回值类型无关

shift + f6 选中它，按住改快捷键，所有关于它的都会统一更改

【数组】
	基本格式：
		数据类型[] 数组名称  = new 数据类型[10]
		数据类型[] 数组名称  = new 数据类型[]{元素1，元素2，。。。};
	省略格式：
		数据类型[] 数组名称  = {元素1，元素2，。。。};
		
	动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数组元素个数
	静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定
	
	注意事项：
		1. 虽然静态初始化好没有直接告诉长度，但是根据大括号里的元素具体内容，也可以自动推算出来长度
		2. 静态初始化标准格式可以拆分为两个步骤
		3. 动态初始化标准格式可以拆分为两个步骤
		4. 静态初始化一旦使用省略格式，就不能拆分为两个格式了
	使用建议：
		如果不确定使用当中的具体内容，用动态初始化，否则，已经确定了具体的内容，用静态初始化
	数组一旦创建，程序运行期间，长度不可改变
	数组元素反转，起始就是对称位置的元素交换	
	数组可以作为方法的参数
	数组作为返回类型

【内存】
	java的内存需要划分成为5个部分：
	1.栈（stack）：存放的都是方法中的局部变量，方法的运行一定要在栈当中运行
		局部变量：方法的参数，或者是方法{}内部的变量
		作用域：一旦超出作用于域，立刻从栈内存当中消失
	2.堆（Heap）：凡是new出来的数据，都在堆当中
		堆里面的东西都有一个地址值：16进制
		堆内存里面的数据，都有默认值，规则：
			int  0
			float 0.0
			char '\u0000'
			boolean false
			引用 null
	3.方法区（Method Area） ：存储class相关信息，包含方法信息
	4.本地方法栈（Native Method Stack ）：与操作系统相关
	5.寄存器（PC Register）：与CPU相关

【类】
	成员变量 成员方法
	带有static的是普通方法，不需要对象直接调用
	当一个对象作为参数，传递到方法当中时，实际上传递进去的是对象的地址值
	当使用一个对象类型作为方法的返回值时，返回值其实就是对象的地址值
	
【局部变量和成员变量】
	1. 定义的位置不一样【重点】
	局部变量：在方法内部
	成员变量：在方法的外部，直接写在类当中

	2. 作用范围不一样【重点】
	局部变量：只有方法当中才可以使用，出了方法就不能使用
	成员变量：整个类全都可以通用

	3. 默认值不一样【重点】
	局部变量：没有默认值，如果要使用，必须手动进行赋值
	成员变量：如果没有赋值，会有默认值，规则和数组一样

	4. 内存的位置不一样（了解）
	局部变量：位于栈内存
	成员变量：位于堆内存

	5. 生命周期不一样（了解）
	局部变量：随着方法进栈而诞生，随着方法出栈而消失
	成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失
		
【封装】
	问题描述：定义Person的年龄是，无法阻止不合理的数值被设置进来。
	解决方案：用private关键字将需要保护的成员变量进行修饰。

	一旦使用了private进行修饰，那么本类当中仍然可以随意访问。
	但是，超出了本类的范围之外就不能在直接访问了。

	间接访问private成员变量，就是定义一对儿getter/setter方法

	必须叫setXxx或者是getXxx命名规则
	对于Getter来说，不能有参数，返回值类型和成员变量对应
		对于基本数据类型当中的boolean值，Getter方法一定要写成isXXX的形式，而setXXX规则不变
	对于setter来说，不能有返回值，返回值类型和成员变量对应。
		
【this】
	当方法的局部变量和类的局部变量重名的的时候，根据“就近原则”，优先使用局部变量
	如果需要访问本类当中的成员变量，需要使用格式：
	this.成员变量

	“通过谁调用的方法，谁就是this”

【构造方法】
	构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象是，其实就是在调用构造方法
	格式：
	public 类名称（参数类型 参数名称）{
		方法体
	}

	注意事项：
	1. 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样
	2. 构造方法不要写返回值类型，连void都不写
	3. 构造方法不能return一个具体的返回值（构造方法没有返回值）
	4. 如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做
	public Student（）{}
	5. 一旦编写了至少一个构造方法，那么编译器将不再赠送
	重载：方法名称相同，参数列表不同	

【一个标准类】
	一个标准的类通常要有拥有下面四个组成部分：

	1. 所有的成员变量都要使用private关键字修饰
	2. 为每一个成员变量编写一对儿Getter/Setter方法
	3. 编写一个无参数的构造方法
	4. 编写一个全参数的构造方法

	这样标准的类页叫做Java Bean

【Scanner类】
	Scanner类的功能，可以实现键盘输入数据，到程序当中

	引用类型的一般步骤：

	1. 导包
	import 包路径.类名称；
	如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写
	只有java.lang包下的内容不需要导包，其他的包都需要import语句

	2. 创建
	类名称 对象名 = new 类名称（）；

	3. 使用
	对象名.成员方法名（）

	获取键盘输入的一个int数字：int num = sc.nextInt();
	获取键盘输入的一个String：String str = sc.next();

【匿名对象】
	创建对象的标准格式：
	类对象 对象名 = new 类名称（）；

	匿名对象就是只有右边的对象，没有左边的名字和赋值运算符
	new 类名称（）；

	注意事项：匿名对象只能使用唯一一次，下次再用不得不创建一个新的对象
	使用建议：如果确定有一个对象要使用唯一的一次，就可以用匿名对象。
	
introduce local variable	

【Random类】
	Random类用来生成随机数字。使用起来也是三个步骤：

	1. 导包
	import java.util.Random;

	2. 创建
	Random r = new Random(); // 小括号中留空即可

	3. 使用
	获取一个随机分布的int数字(范围是int所有的范围，由正负两种)：int num = r.nextInt();
	获取一个随机分布的int数字(参数代表了范围，左闭右开区间)：int num = r.nextInt(3);
	实际上代表的含义是：[0,3),也就是0~2
	
【ArrayList类】
	数组的长度不可以发生改变
	但是ArrayList集合的长度是可以随意改变的

	ArrayList<String> list = new ArrayList<>();

	list.add("Alex");

	对于ArrayList来说，有一个尖括号<E>代表泛型
	泛型：也就是装在集合当中的所有元素，全都是统一的什么类型
	注意：泛型只能是引用类型，不能是基本类型

	注意事项：
	对于ArrayList集合来说，直接打印得到的不是地址值，而是内容
	如果内容的空，得到的是框的中括号：[]
	
	ArrayList当中的常用方法有：
		public boolean add(E e): 向集合当中添加元素，参数的类型和泛型一致
			备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。
			但是对于其他集合（今后学习）来说，add添加动作不一定成功。
		public E get（int index): 从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素。
		public E remove(int index): 从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素
		public int size(): 获取集合的尺寸长度，返回值是集合中包含的元素个数。
	
	
	如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的”包装类“。

	基本类型 包装类（引用类型，包装类都位于java.lang包下）
	byte    Byte
	short   Short
	int     Integer
	long    Long
	float   Float
	double  Double
	char    Character
	boolean Boolean
	从JDK 1.5+开始： 支持自动装箱、自动拆箱
	自动装箱：基本类型 --> 包装类型
	自动拆箱：包装类型 --> 基本类型
	
Scanner、Random和ArrayList类都在java.util包下


【字符串】
	java.lang.String类代表字符串。
	API当中说：Java程序中的字符串字面值（如“abc”）都是作为此类的实例实现
	其实就是说：程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是）

	字符串的特点：
	1. 字符串的内容永不可变。【重点】
	2. 正是因为字符串不可改变，所以字符串是可以共享使用的
	3. 字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组。

	创建字符串的常见3+1种方式：
	三种构造方法：
	public String(): 创建一个空白字符串，不含有任何内容
	public String(char[] array): 根据字符数组的内容，来创建对应的字符串
	public String(byte[] array): 根据字节数组的内容，类创建对应的字符串
	一种直接创建：
	String str = "Hello"

	注意：直接写上双引号，就是字符串对象


	字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。
	new String就不在常量池中了

	对于基本数据类型来说，==是进行数值的比较。
	对于引用类型类型来说，==是进行地址值的比较。


	==是进行对象的地地址值比较，如果确实需要字符串的内容比较，可以使用两个方法

	public boolean equals(Object obj):参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true，否则返回false
	注意事项：
	1. 任何对象都可以使用Object进行接收
	2. equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样
	推荐：“abs”.equals(str)
	不推荐：str.equals("abs")
		String  str5 = null;
        System.out.println("abc".equals(str5)); // 推荐：false
        System.out.println(str5.equals("abc")); // 不推荐：报错：空指针异常NullPointerException

	public boolean equalsIgnoreCase（String str）：忽略大小写，进行内容比较

	
	String当中与获取相关的常用方法有：
	public int length():获取字符串当中含有的字符个数，拿到字符串长度。（数组点length是没有括号的）
	public int concat(String str): 将当前字符串和参数字符串拼接成为返回新的字符串。
	public char charAt(int index): 获取指定索引位置的单个字符。（索引从0开始）
	public int indexOf(String str): 查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值

	
	字符串的截取方法：

	public String substring(int index): 截取从参数位置一直到字符串末尾，返回新字符串。
	public String substring（int begin，int end）：截取从begin开始，一直到end结束，中间的字符串。
	备注：[begin,end),包含左边，不包含右边


	String当中与转换相关的常用方法有：

	public char[] toCharArray(): 将当前字符串拆分成字符数组作为返回值。
	public byte[] getBytes(): 获得当前字符串底层的字节数组。
	public String replace(CharSequence oldString, CharSequence newString)
	将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串
	备注：CharSequence意思就是说可以接受字符串类型


	分割字符串的方法：
	public String[] split(String regex):按照参数的规则，将字符串切分为若干部分（即返回数组）

	注意事项:
	split方法的参数其实是一个“正则表达式”，今后的学习。
	今天要注意，如果按照英文句点“.”进行切分，必须切分，必须写“\\.”（两个反斜杠）


【static关键字】	
	一旦使用了static关键字，那么这样的内容不再属于对象自己，
	而是属于类的，所以凡是本类的对象，都共享一份


	一旦使用static修饰成员方法，那么这就成为了静态方法。
	静态方法不属于对象，而是属于类的。	

	如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。
	如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。
		// 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用
        obj.methodStatic(); // 正确，不推荐
        MyClass.methodStatic(); // 正确，推荐
	
	无论是成员变量，还是成员方法，如果有了static，都推荐使用类名称进行调用。
	静态变量：类名称.静态变量
	静态方法：类名称.静态方法()
	
		// 对于本类当中的静态方法，可以省略类名称
		myMethod();
		Demo02StaticMethod.myMethod(); // 完全等效

	注意事项：
	1. 静态不能直接访问的非静态
	原因：因为在内存当中是【先】有的静态内容，【后】的非静态内容。
	“先人不知道后人，但是后人知道先人”
	2. 静态方法当中不能用this
	原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。
	
	
	【静态代码块】
		静态代码块的格式是：

		public class 类名称{
			static{
				// 静态代码块的内容
			}
		}

		特点：当第一次用到本类时，静态代码块执行唯一的一次
		静态内容总是优先于非静态，所以静态代码块比构造方法先执行。

		静态代码块的典型用途：
		用来一次性地对静态成员变量进行赋值
		

【Arrays类】
	java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组的常见操作

	public static String toString(数组）：将参数数组变成字符串（按照默认格式：[元素1，元素2，元素3，。。。])
	public static void sort(数组）：按照默认升序（从小到大）对数组的元素进行排序。

	备注：
	1. 如果是数值，sort默认按照升序从小到大
	2. 如果是字符串，sort默认按照字母升序
	3. 如果是自定义的类型，那么这个是自定义的类需要有Comparable或者Comparator接口支持（今后学习）
	
	
	
【Math类】
	java.util.Math是数学相关的工具类，里面提供了大量的静态方法，完成与数学相关的操作。

	public static double abs(double num)：获取绝对值。
	public static double ceil(double num)：向上取整。
	public static double floor(double num)：向下取整。
	public static long round(double num)：四舍五入。

	Math.PI: 代表近似的圆周率常量（double）
	
	
【继承】
	面向对象的三大特征：封装性，继承性，多态性
	继承是多态的前提，如果没有继承，就没有多态
	
	继承主要解决的问题就是：共性抽取
	
	继承关系当中的特点：
	1. 子类可以拥有父类的“内容”
	2. 子类还可以拥有自己专有的新内容
	
	
	在父子类的继承关系中，如果成员变量重名，则创建子类对象是，访问格式也有两种方式

	直接通过子类对象访问成员变量：
		等号左边用谁，就优先用谁，没有就向上找。
	间接通过成员方法访问成员变量；
		该方法属于谁，就优先用谁，没有则向上找。
	
	
	在父子类的继承关系当中，创建子类对象，访问成员方法的规则
		创建的对象是谁，就优先用谁，如果没有则向上找
		
	注意事项：
	无论是成员方法还是成员变量，如果没有都是向上找，绝对不会向下找子类的。
	
	
	【重写（Override)】
	概念：在继承关系当中，方法的名称一样，参数的列表也一样，参数列表也一样。
	重写（Override）：方法的名称一样，参数列表【也一样】
	重载（Overload）：方法的名称一样，参数列表【不一样】
	
	方法的覆盖重写的注意事项：
	1. 必须保证父子类直接方法的名称相同，参数列表也相同
	@Override: 写在方法前面，用来检测是不是有效的正确覆盖重写。
	这个注解就算不写，只要满足要求，也是正确的覆盖重写

	2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。
	小扩展提示：java.lang.String类所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类

	3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。
	小扩展提示：public > protected > (default) > private

	备注: (default)不是关键字default，而是什么都不写，留空
	
	
	设计原则：对于已经投入使用的类，尽量不要进行更改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动的新内容
	
	
	继承关系中，父子类构造方法的访问特点。

	1. 子类构造方法当中有一个默认隐含的“super()"调用，所以一定是先调用的父类构造，后执行的子类构造.
	2. 子类构造可以通过super关键字来调用父类重载构造。
	3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。
		只有子类构造方法才能调用父类构造方法。
		
	总结：
	子类必须调用父类构造方法，不写则赠送super():写了则用写的指定的super调用，super只能有一个，还必须是第一个。
	
	
	super关键字的用法有三种:
	1. 在子类的成员方法中，访问父类的成员变量。
	2. 在子类的成员方法中，访问父类的成员方法。
	3. 在子类的构造方法中，访问父类的构造方法。
	
	
	super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：
	1. 在本类的成员方法中，访问本类的成员变量。
	2. 在本类的成员方法中，访问本类的另一个成员方法。
	3. 在本类的构造方法中，访问本类的另一个构造方法。’
		在第三种用法当中要注意：
			this(...)调用也必须是构造方法的第一个语句，也是唯一一个。
			super和this两种构造调用，不能同时使用。
	
========	
	java语言是单继承的。
	一个类的直接父类只能有唯一一个。
	
	java语言可以多级继承	
	
	一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类。
	可以有很多个兄弟姐妹，生二胎。
	
	
【抽象】
	抽象的概念：
	（抽象方法：抽象类中的方法在本类中无法表达或者具体化，只能下放到具体的子类才能写出具体代码）
	即如果父类的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法。

	
	抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。
	抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。

		public abstract class Animal {

			// 这就是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。
			public abstract void eat();

			// 这是普通的成员方法
			public void normalMethod(){

			}
		}


	如何使用抽象类和抽象方法：
	1. 不能直接创建new抽象类对象。
	2. 必须用一个子类类继承抽象父类。
	3. 子类必须覆盖重写抽象父类当中所有的抽象方法
	覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
		Ctrl + O ：覆盖重写方法（Override Method）
		Ctrl + I ：实现方法（Implement Method）
	4. 创建子类对对象进行使用


	一个抽象类中不一定含有抽象方法，
	只要保证抽象方法所在的类是抽象类，即可。

	这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景下有用途。
	
	
	注意事项：
	1. 抽象类不能直接创建对象，只能创建器非抽象子类的对象
	2. 抽象类中，可以有构造方法，是供子类创建对象是，初始化父类成员使用的。
	3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类
	4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错，除非子类也是抽象类


【接口】
	接口就是一种公共的规范标准。
	只要符合规范标准，就可以大家通用


	接口就是多个类的公共接口规范。
	接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。
	如何定义一个接口的格式：
	public interface 接口名称 {
		// 接口内容
	}

	备注：换成了关键字interface之后，编译生成的字节码文件是：.java --> .class。

	如果是Java 7，那么接口中的可以包含的内容有：
	1. 常量
	2. 抽象方法：（接口中的基本方法，实现类必须实现的方法，没有方法体）

	如果是Java 8，还可以额外包含有:
	3. 默认方法：（解决接口升级的问题，实现类可以自动继承，有方法体）
	4. 静态方法：（实现类对象不能直接调用，而是用接口调用）

	如果是Java 9，还可以额外包含有：
	5. 私有方法：（解决多个默认/静态方法之间重复代码问题）


	在任何版本的Java中，接口都能定义【抽象方法】：
	格式：
		public abstract 返回值类型 方法名称（参数列表）;

	注意事项：
	1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
	2. 这两个关键字修饰符，可以选择性的省略。（今天新学，所以不推荐）
	3. 方法的三要素，可以随意定义。


	接口使用步骤：
	1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。
	格式：
		public class 实现类名称 implements 接口名称{
			// 。。。
		}
	2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法
	实现：去掉abstract关键字，加上方法体大括号。
	3. 创建实现类的对象，进行使用。
	
	注意事项：
	如何实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类


	从Java 8开始，接口里允许定义【默认方法】。
	格式：
		public default 返回值类型 方法名称（默认方法）{
			方法体
		}
	备注：接口当中的默认方法，可以解决接口升级的问题。
	
	1. 接口的默认方法，可以通过接口的实现类对象，直接调用。
	2. 接口的默认方法，也可以被接口实现类进行覆盖重写。


	从Java 8开始，接口当中允许定义【静态方法】。
	格式：
		public static 返回值类型 方法名称（参数列表）{
			方法体
		}
	提示：就是将abstract或者default换成static即可，带上方法体。

	注意事项：不能通过接口实现类的对象类调用接口当中的静态方法。
	正确用法：通过接口名称，直接调用其中的静态方法。
	格式：
	接口名称.静态方法名称（参数）；

	
	问题描述：
	我们需要抽取一个公共方法，用来就解决两个默认方法之间重复代码的问题。
	但是这个共有方法不应该让实现类使用，应该是私有化的。
	解决方案：
	从Java 9开始，接口当中允许定义【私有方法】。
	1. 普通私有方法：解决多个默认方法之间重复代码问题
	格式：
		private 返回值类型 方法名称（参数列表）{
			方法体
		}
	2. 静态私有方法：解决多个静态方法之间重复代码问题
	格式：
		private static 返回值类型 方法名称（参数列表）{
			方法体
		}


	接口当中不管是什么版本，也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。
	从效果上看，这其实就是接口的【常量】。
	格式：
		public static final 数据类型 常量名称 = 数据值；
	备注：
	一旦使用final关键字进行修饰，说明不可改变。

	注意事项：
	1. 接口当中的常量，可以省略public static final，注意，不写也照样是这样。
	2. 接口当中的常量，必须进行赋值，不能不赋值。
	3. 接口的中常量的名称，使用完全大写的字母。用下划线进行分割，（推荐命名规则）
	
	

	在Java 9+版本当中，接口的内容可以有：
	
	1. 成员变量其实是常量，格式：
		[public][static][final] 数据类型 常量名称 = 数据值;
	注意：
		常量必须进行赋值，而且一旦赋值不能改变。
		常量名称完全大写，用下划线进行分割。
	
	2. 接口中最重要的就是【抽象方法】，格式：
	[public] [abstract] 返回值类型 方法名称（参数列表）;
	注意：实现类必须覆盖重写接口所有的抽象方法，除非事先类是抽象类。
	
	3. 从Java 8开始，接口里允许定义【默认方法】。格式：
	[public] default 返回值类型 方法名称（参数列表）{方法体}
	注意：默认方法也可以被覆盖重写
	
	4. 从Java 8开始，接口里允许定义【静态方法】，格式：
	[public] static 返回值类型 方法名称（参数列表）{方法体}
	注意：应该通过接口进行调用，不能通过实现类对象调用接口静态方法。
	
	5. 从Java 9开始，接口里允许定义【私有方法】，格式：
	普通私有方法：private 返回值类型 方法名称（参数列表）{方法体}
	静态私有方法：private static 返回值类型 方法名称（参数列表）{方法体}
	注意：private的方法只能接口自己才能调用，不能被实现类或别人使用。
	
	
	
【继承父类并实现多个接口】	
	使用接口的时候，需要注意：
	1. 接口是没有静态代码块或者构造方法的。
	2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
	格式：
		public class MyInterfaceImpl implements MyInterfaceA，MyInterfaceB{
			 // 覆盖重写所有的抽象方法
		}
	3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
	4. 如果实现类没有重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
	5. 如果实现类所实现的多个接口当中，存在重复的默认方法，实现类一定要对冲突的默认方法进行覆盖重写。就算是实现类是抽象类也要重写。
	6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法，优先使用父类当中的方法。(继承优于接口实现）
	
	
	1. 类与类之间是单继承的。直接父类只有一个。
	2. 类与接口之间是多实现的。一个类可以实现多个接口。
	3. 接口与接口之间是多继承的。

	注意事项：
	1. 多个父接口当中的抽象方法如果重复，没关系。
	2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且要带着default关键字】。
	
	
	
	
面向对象的三大特征：封装性，继承性，多态性
	extends继承或者implements实现，是多态性的前提。
	

【多态】（左父右子）	
	代码当中体现多态性，其实就是一句话：父类引用指向子类对象。
	格式：
	父类名称 对象名 = new 子类名称（）;
	或者：
	接口名称 对象名 = new 实现类名称（）;
	
	
	访问成员变量（对，没写错就是成员变量）的两种方式：
	1. 直接通过子类对象访问成员变量：等号左边用谁，就优先用谁，没有就向上找。
		（成员变量没有覆盖重写一说，所以左边用谁引用即访问谁的成员变量）
	2. 间接通过成员方法访问成员变量；该方法属于谁，就优先用谁，没有则向上找。
		即（只有父类有，则理所当然当调用父类的该成员方法；若子类覆盖重写了该方法，则就调用子类的方法）
	
	
	在多态的代码当中，成员方法的访问规则是：
		看new的是谁，就优先用谁，没有则向上找
	对比一下：
	成员变量：编译看左边，运行还看左边
	成员方法：编译看左边，运行看右边
	
	（注意！！！：子类中新添加的特有的成员方法，使用多态new出的对象是不能用的）
		所以有三种情况需要考虑：
			1. 父类有的方法，子类没有
				当然是使用父类的
			2. 父类有的方法，子类有（即覆盖重写）
				费劲重写的当然用子类的
			3. 父类没有的方法，子类有（用多态和不用多态区别就在这）
				多态的情况下，编译不通过
				正常情况下是调用子类方法	
	
	
	举例说明多态的好处：
	父类或者接口 员工（Employee） 
				 work(); // 抽象方法
	子类或者实现 讲师（Teacher）、助教（Assistance） 继承或实现员工
				 work(){讲课}      work(){辅导}
	
		1. 如果不用多态，只用子类，那么写法是：
			Teacher one = new Teacher();
			one.work(); // 讲课
			Assistance two = new Assistance();
			two.work(); // 辅导
			
		我现在唯一要做的事情，就是调用work方法，其他功能不关心。
		
		2. 如果使用多态的写法，对比一下：
			Employee one = new Teacher();
			one.work(); // 讲课
			Employee two = new Assistance();
			two.work(); // 辅导
		
		好处：无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化
	

	
【对象的向上转型】
	1. 对象的向上转型，其实就是多态写法：
	格式：父类名称 对象名 = new 子类名称（）；				Animal animal = new Cat（）；
	含义：右侧创建一个子类对象，把他当做父类来看待使用。	创建了一只猫，当做动物来看待，没问题。
	注意事项：向上转型一定是安全的。从小范围转向了大范围。
	
	类似于：
	double num = 100；正确 int-->double,自动类型转换。
	
	向上转型一定是安全的，没有问题的，正确的，但是也有一个弊端：
	对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。

	解决方案：用对象的向下转型【还原】。


【对象的向下转型】
	2.对象的向下转型，其实就是一个【还原】的动作.
	格式：子类名称 对象名 = （子类名称）父类对象；
	含义：将父类对象，【还原】成为本来的子类对象。
	
	Animal animal = new Cat（）；// 本来是猫，向上转型成为动物
	Cat cat = （Cat） animal；// 本来是猫，已经被当成做是动物了，还原回来成为本来的猫
		cast to 自动加上向下转型
	注意事项：
	a.必须保证对象本来创建的时候，就是猫，才能向下转型成为猫。
	b.如果对象创建的时候本来不是猫，现在非要向下转型成为猫，
		编译正常，运行就会报错java.lang.ClassCastException:类转换异常。
		

【instanceof】
	如何知道一个父类引用的对象，本来是什么子类？
	格式：
	对象 instanceof 类型
	这将得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。
	（向下转型一定要进行instanceof判断）
	
	usb接口案例
	
	
	
【final】	
	final关键字代表最终。不可改变的。

	常见的四种用法：
	1. 可以用来修饰一个类
		当final关键字用来修饰一个类的时候，格式：
			public final class 类名称 {
				// ...
			}
		含义: 当前这个类不能有任何子类。（太监类）
		注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写，因为没有子类（儿子）。
	2. 可以用来修饰一个方法
		当final关键字用来修饰一个方法的的时候，这个方法就是最终方法，也就是不能被覆盖重写。
		格式：
			修饰符 final 返回值类型 方法名称（参数列表）{
				// 方法体
			}
		注意事项：
		对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。
	3. 还可以用来修饰一个局部变量
		一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。
		一次赋值终生不变
		正确写法！只要保证有唯一一次赋值即可
		对于基本数据类型来说，不可变说的是变量当中的数据不可变
		对于引用数据类型来说，不可变说的是变量当中的地址值不可变
		final修饰的引用类型变量，其中的地址值不可改变,但地址值所指向的内容可以改变
	4. 还可以用来修饰一个成员变量
		对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变的。
		1. 由于成员变量具有默认值，所以用了final之后必须手动赋值。不会再给默认值了。
		2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。
		3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。
	
	

【四种权限修饰符】
Java中有四种权限修饰符：
				public > protected > (default) > private
	同一个类        YES      YES         YES         YES    （我自己）
	同一个包        YES      YES         YES         NO     （我邻居）
	不同包子类      YES      YES         NO          NO     （我儿子）
	不同包非子类    YES      NO          NO          NO     （陌生人）

	注意事项：（default）并不是关键字“default”，而是根本不写。	
	
	
	
【内部类】
	如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。
	例如：身体和心脏。又如：汽车和发动机的关系。

	分类：
	1. 成员内部类
	2. 局部内部类（包含匿名内部类）
	
	成员内部类的定义格式：
		修饰符 class 外部类名称 {
			修饰符 class 内部类名称 {
				// ...
			}
			// ...
		}
	注意：内用外，随意访问；外用内，需要内部类对象。
	
	
	shift + ctrl + f9 recomplie ’body。java‘ 会产生一个两个类body.class和body$heart.class
	

【成员内部类】	
	如何使用成员内部类？有两种方式：
	1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。
		通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart
	2. 直接方式：公式：
	一般：类名称 对象名 = new 类名称（）；
	【外部类名称.内部类名 对象名 = new 外部内名称（）.new 内部类名称（）；】
	
	
	内部类与外部类的变量重名是如何引用
	System.out.println(num); // 内部局部变量
	System.out.println(this.num); // 内部类的成员变量
	System.out.println(Outer.this.num); // 外部类的成员变量


【局部内部类】
	如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。
	”局部“：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

	定义格式：
		修饰符 class 外部类名称 {
			修饰符 返回值类型 外部类方法名称（参数列表）{
				class 局部内部类名称{
					// ...
				}
			}
		}

	小结一下类的权限修饰符：
	public  protected （default） private
	定义一个类的时候，权限修饰符规则：
	1. 外部类：public / (default)
	2. 成员内部类: public / protected / (default) / private
	3. 局部内部类: 什么都不写
		
	
	局部内部类，如果希望所在方法的局部内部类，那么这个局部变量必须是【有效final的】。

	备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。

	原因：
	1. new出来的对象在堆内存当中
	2. 局部变量时跟着方法走的，在栈内存当中。
	3. 方法运行结束之后，立即出栈，局部变量就会立刻消失。
	4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。
	
	
	
【匿名内部类】
	如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，
	那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。

	匿名内部类的定义格式：
		接口名称 对象名 = new 接口名称(){
			// 覆盖重写所有抽象方法
		}
		
	实现一个接口需要在定义一个类来实现，我们可以直接通过匿名内部类来实现，就不需要新定义一个类了。
	
	对格式“new 接口名称（）{。。。}”进行解析：
	1. new代表创建对象的动作
	2. 接口名称就是匿名内部类需要实现哪个接口
	3. {。。。}这才是匿名内部类的内容

	另外还要注意几点问题：
	1. 匿名内部类，在创建对象的时候只能使用唯一一次。
		如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。
	2. 匿名对象，在【调用方法】的时候，只能调用唯一一次。
		如果希望同一个对象，调用多次方法，那么必须给对象起个名字
	3. 匿名内部类是省略了【实现类/子类】，但是匿名对象是省略了【对象名称】
	强调：匿名内部类和匿名对象不是一回事！！！
	
	类可以作为成员变量类型
	接口可以作为成员变量类型
	
	
	
	
【IO】
【FileOutputStream】
	java.io.OutputStream:字节输出流
	此抽象类是表示输出字节流的所有类的超类。
	定义了一些子类共性的成员方法：
		- public void close(): 关闭此输出流并释放与此流相关联的任何系统资源。
		- public void flush(): 刷新此输出流并强制阮芳的缓冲的输出字节被写出。
		- public void write(byte[] b):  将b.length字节中指定的字节数组写入此输出流。
		- public void write(byte[] b， int off, int len): 从指定的字节数组写入len字节，从偏移量off开始输入到此输出流。
		- public abstract void write(int b): 将指定的字节输出流。
		
	java。io.FileOutputStream extends OutputStream
	FileOutputStream:文件字节输出流
	作用：把内存的中的数据写入到硬盘的文件中

	构造方法：
		FileOutputStream（String name）创建一个向指定名称的文件中写入数据的输入文件流。
		FileOutputStream（File file）创建一个向指定file对象表示的文件中写入数据的输入文件流。
		参数：写入数据的目的
			String name：目的地是一个文件的路径
			File file：目的地是一个文件
		构造方法的作用：
			1. 创建一个FileOutoutStream对象
			2. 会根据构造方法中传递的文件/文件路径，创建一个空的文件
			3。会把FileOutputStream对象指向创建好的文件

	写入数据的原理（内存-->硬盘）
		Java程序-->JVM（Java虚拟机）-->OS(操作系统）-->OS调用写数据的方法-->把数据写入到文件中

	字节输出流的使用步骤【重点】：
		1. 创建一个FileOutputStream对象，构造方法中传递写入数据的目的地
		2. 调用FileOutputStream对象中的方法write，把数据写入到文件中
		3. 释放资源（流使用会占用一定的内存，使用完毕要把内存清空，提高程序的效率）
	

一次写多个字节的方法：
    - public void write(byte[] b):  将b.length字节中指定的字节数组写入此输出流。
    - public void write(byte[] b， int off, int len): 从指定的字节数组写入len字节，从偏移量off开始输入到此输出流。

如果写的第一个字节是正数（0~127），那么显示的时候回查询ASCII表
如果写的第一个字符是负数，那第一个字节和第二个字节，两个字节组成一个中文显示，查询系统n=morf码表（GBK）	
	
写入字符的方法：可以使用String类中的方法把字符串，转换为字节数组


追加写/续写 ：使用两个参数的构造方法
    FileOutputStream（String name, boolean append）创建一个向指定名称的文件中写入数据的输出文件流。
    FileOutputStream（File file, boolean append）创建一个向指定file对象表示的文件中写入数据的输出文件流。
    参数：
        String nae，File file：写入数据的目的地
        boolean append：追加写开关
    写换行：写换行符号
        Windows：\r\n
        linux: /n
        mac: /r
		
	FileOutputStream fos = new FileOutputStream("09_IOAndProperties\\b.txt",true);
	for (int i = 0; i < 10; i++) {
		fos.write("你好".getBytes());
		fos.write("\r\n".getBytes());
	}
	fos.close();
	
	
【FileInputStream】

	java.io.InpuStream: 字节输入流
	此抽象类是表示字节输入流的所有类的超类。

	定义了所有子类共用的方法：
		int read() 从输入流中读取数据的下一字节。
		int read(byte[] b)从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
		void close() 关闭此输入流并释放与该流关联的所有系统资源。

	FileInputStream extends InputStream
	FileInputStream: 文件字节输入流
	作用：把硬盘文件中的数据，读取到内存中使用

	构造方法：
		FileInputStream(File file) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。
		FileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。
		参数：读取文件的的数据源
			String name：文件的路径
			File file：文件
		构造方法的作用：
			1. 会创建一个FileInputStream对象
			2. 会把FileInputStream对象指向构造方法中要执行的文件

		 读取数据的原理（硬盘-->内存）
		 Java程序-->JVM（Java虚拟机）-->OS(操作系统）-->OS调用读取数据的方法-->读取文件

		字节输如流的使用步骤【重点】：
			1. 创建一个FileInputStream对象，构造方法中绑定要读取的数据源
			2. 调用FileInputStream对象中的方法read，读取文件
			3. 释放资源


	布尔表达式(len = fis.read()) != -1:
		1. fis.read(): 读取一个字节
		2. len = fis。read（）：把读取到的字节赋值给变量len
		3. (len = fis.read()) != -1：判断变量len是否不等于-1
		
	FileInputStream fis = new FileInputStream("09_IOAndProperties\\a.txt");	
	int len = 0;
	while ((len = fis.read()) != -1) {
		System.out.print((char) len);
	}
	fis.close();	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	